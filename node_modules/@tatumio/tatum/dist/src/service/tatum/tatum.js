"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TatumSDK_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TatumSDK = exports.Tezos = exports.Tron = exports.Solana = exports.Xrp = exports.BitcoinCash = exports.Dogecoin = exports.Litecoin = exports.Bitcoin = exports.HorizenEon = exports.Xdc = exports.Vechain = exports.Polygon = exports.Palm = exports.Optimism = exports.Oasis = exports.Kucoin = exports.Klaytn = exports.HarmonyOne = exports.Flare = exports.Haqq = exports.Gnosis = exports.Fantom = exports.EthereumClassic = exports.Cronos = exports.Celo = exports.BinanceSmartChain = exports.AvalancheC = exports.Aurora = exports.ArbitrumOne = exports.ArbitrumNova = exports.Ethereum = exports.BaseEvmClass = exports.BaseUtxoClass = exports.BaseTatumSdk = exports.TatumSdkChain = void 0;
const typedi_1 = require("typedi");
const dto_1 = require("../../dto");
const util_1 = require("../../util");
const address_1 = require("../address");
const fee_1 = require("../fee");
const nft_1 = require("../nft");
const notification_1 = require("../notification");
const rate_1 = require("../rate");
const LoadBalancer_1 = require("../rpc/generic/LoadBalancer");
const token_1 = require("../token");
const walletProvider_1 = require("../walletProvider");
const tatum_dto_1 = require("./tatum.dto");
const extensions_1 = require("../extensions");
class TatumSdkChain {
    constructor(id) {
        this.id = id;
    }
    extension(type) {
        return typedi_1.Container.of(this.id).get(type);
    }
    destroy() {
        typedi_1.Container.of(this.id).reset({ strategy: 'resetServices' });
    }
}
exports.TatumSdkChain = TatumSdkChain;
class BaseTatumSdk extends TatumSdkChain {
    constructor(id) {
        super(id);
        this.notification = typedi_1.Container.of(id).get(notification_1.Notification);
        this.nft = typedi_1.Container.of(id).get(nft_1.Nft);
        this.token = typedi_1.Container.of(id).get(token_1.Token);
        this.walletProvider = typedi_1.Container.of(id).get(walletProvider_1.WalletProvider);
        this.address = typedi_1.Container.of(id).get(address_1.Address);
        this.rates = typedi_1.Container.of(id).get(rate_1.Rates);
    }
}
exports.BaseTatumSdk = BaseTatumSdk;
class BaseUtxoClass extends BaseTatumSdk {
    constructor(id) {
        super(id);
        this.rpc = util_1.Utils.getRpc(id, typedi_1.Container.of(id).get(util_1.CONFIG));
        this.fee = typedi_1.Container.of(id).get(fee_1.FeeUtxo);
    }
}
exports.BaseUtxoClass = BaseUtxoClass;
class BaseEvmClass extends BaseTatumSdk {
    constructor(id) {
        super(id);
        this.rpc = util_1.Utils.getRpc(id, typedi_1.Container.of(id).get(util_1.CONFIG));
    }
}
exports.BaseEvmClass = BaseEvmClass;
class Ethereum extends BaseEvmClass {
    constructor(id) {
        super(id);
        this.fee = typedi_1.Container.of(id).get(fee_1.FeeEvm);
    }
}
exports.Ethereum = Ethereum;
class ArbitrumNova extends BaseEvmClass {
}
exports.ArbitrumNova = ArbitrumNova;
class ArbitrumOne extends BaseEvmClass {
}
exports.ArbitrumOne = ArbitrumOne;
class Aurora extends BaseEvmClass {
}
exports.Aurora = Aurora;
class AvalancheC extends BaseEvmClass {
}
exports.AvalancheC = AvalancheC;
class BinanceSmartChain extends BaseEvmClass {
}
exports.BinanceSmartChain = BinanceSmartChain;
class Celo extends BaseEvmClass {
}
exports.Celo = Celo;
class Cronos extends BaseEvmClass {
}
exports.Cronos = Cronos;
class EthereumClassic extends BaseEvmClass {
}
exports.EthereumClassic = EthereumClassic;
class Fantom extends BaseEvmClass {
}
exports.Fantom = Fantom;
class Gnosis extends BaseEvmClass {
}
exports.Gnosis = Gnosis;
class Haqq extends BaseEvmClass {
}
exports.Haqq = Haqq;
class Flare extends BaseEvmClass {
}
exports.Flare = Flare;
class HarmonyOne extends BaseEvmClass {
}
exports.HarmonyOne = HarmonyOne;
class Klaytn extends BaseEvmClass {
}
exports.Klaytn = Klaytn;
class Kucoin extends BaseEvmClass {
}
exports.Kucoin = Kucoin;
class Oasis extends BaseEvmClass {
}
exports.Oasis = Oasis;
class Optimism extends BaseEvmClass {
}
exports.Optimism = Optimism;
class Palm extends BaseEvmClass {
}
exports.Palm = Palm;
class Polygon extends BaseEvmClass {
}
exports.Polygon = Polygon;
class Vechain extends BaseEvmClass {
}
exports.Vechain = Vechain;
class Xdc extends BaseEvmClass {
}
exports.Xdc = Xdc;
class HorizenEon extends BaseEvmClass {
}
exports.HorizenEon = HorizenEon;
// UTXO chains
class Bitcoin extends BaseUtxoClass {
}
exports.Bitcoin = Bitcoin;
class Litecoin extends BaseUtxoClass {
}
exports.Litecoin = Litecoin;
class Dogecoin extends BaseUtxoClass {
}
exports.Dogecoin = Dogecoin;
class BitcoinCash extends BaseUtxoClass {
}
exports.BitcoinCash = BitcoinCash;
// other chains
class Xrp extends BaseTatumSdk {
    constructor(id) {
        super(id);
        this.rpc = util_1.Utils.getRpc(id, typedi_1.Container.of(id).get(util_1.CONFIG));
    }
}
exports.Xrp = Xrp;
class Solana extends BaseTatumSdk {
    constructor(id) {
        super(id);
        this.rpc = util_1.Utils.getRpc(id, typedi_1.Container.of(id).get(util_1.CONFIG));
    }
}
exports.Solana = Solana;
class Tron extends TatumSdkChain {
    constructor(id) {
        super(id);
        this.notification = typedi_1.Container.of(id).get(notification_1.Notification);
        this.nft = typedi_1.Container.of(id).get(nft_1.Nft);
        this.token = typedi_1.Container.of(id).get(token_1.Token);
        this.walletProvider = typedi_1.Container.of(id).get(walletProvider_1.WalletProvider);
        this.address = typedi_1.Container.of(id).get(address_1.AddressTron);
        this.rates = typedi_1.Container.of(id).get(rate_1.Rates);
        this.rpc = util_1.Utils.getRpc(id, typedi_1.Container.of(id).get(util_1.CONFIG));
    }
}
exports.Tron = Tron;
class Tezos extends TatumSdkChain {
    constructor(id) {
        super(id);
        this.notification = typedi_1.Container.of(id).get(notification_1.Notification);
        this.address = typedi_1.Container.of(id).get(address_1.AddressTezos);
        this.nft = typedi_1.Container.of(this.id).get(nft_1.NftTezos);
    }
}
exports.Tezos = Tezos;
let TatumSDK = TatumSDK_1 = class TatumSDK {
    /**
     * Initialize Tatum SDK. This method must be called before any other method.
     * Default configuration is used if no configuration is provided.
     * @param config
     */
    static async init(config) {
        const defaultConfig = {
            version: tatum_dto_1.ApiVersion.V4,
            retryCount: 1,
            retryDelay: 1000,
            rpc: {
                oneTimeLoadBalancing: false,
                allowedBlocksBehind: util_1.Constant.OPEN_RPC.ALLOWED_BLOCKS_BEHIND,
            },
        };
        const mergedConfig = util_1.Utils.deepMerge(defaultConfig, config);
        // TODO: check when rpc is customized if there is allowedBlocksBehind if not throw error or set default
        // TODO: Check if rpc works for other chains and all configurations are set correctly
        const id = TatumSDK_1.generateRandomString();
        typedi_1.Container.of(id).set(util_1.CONFIG, mergedConfig);
        if ((0, dto_1.isLoadBalancerNetwork)(mergedConfig.network)) {
            const loadBalancer = typedi_1.Container.of(id).get(LoadBalancer_1.LoadBalancer);
            await loadBalancer.init();
        }
        await this.configureExtensions(config, id);
        return util_1.Utils.getClient(id, mergedConfig.network);
    }
    static async configureExtensions(config, id) {
        for (const extensionConfig of config?.configureExtensions ?? []) {
            let type;
            const args = [];
            if ('type' in extensionConfig) {
                type = extensionConfig.type;
                args.push(extensionConfig.config);
            }
            else {
                type = extensionConfig;
            }
            const containerInstance = new extensions_1.TatumSdkContainer(typedi_1.Container.of(id));
            const instance = new type(containerInstance, ...args);
            await instance.init(...args);
            typedi_1.Container.of(id).set(type, instance);
        }
    }
    static generateRandomString() {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < 60; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }
};
TatumSDK = TatumSDK_1 = __decorate([
    (0, typedi_1.Service)({ transient: true })
], TatumSDK);
exports.TatumSDK = TatumSDK;
//# sourceMappingURL=tatum.js.map