"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var LoadBalancer_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadBalancer = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const typedi_1 = require("typedi");
const tatum_connector_1 = require("../../../connector/tatum.connector");
const util_1 = require("../../../util");
const tatum_1 = require("../../tatum");
const NODE_TYPE_LABEL = {
    [tatum_1.RpcNodeType.NORMAL]: 'normal',
    [tatum_1.RpcNodeType.ARCHIVE]: 'archive',
};
let LoadBalancer = LoadBalancer_1 = class LoadBalancer {
    constructor(id) {
        this.id = id;
        this.rpcUrls = {
            [tatum_1.RpcNodeType.NORMAL]: [],
            [tatum_1.RpcNodeType.ARCHIVE]: [],
        };
        this.activeUrl = {
            [tatum_1.RpcNodeType.NORMAL]: {},
            [tatum_1.RpcNodeType.ARCHIVE]: {},
        };
        this.connector = typedi_1.Container.of(this.id).get(tatum_connector_1.TatumConnector);
        this.network = typedi_1.Container.of(this.id).get(util_1.CONFIG).network;
    }
    async init() {
        const config = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        const nodes = config.rpc?.nodes;
        if (nodes) {
            util_1.Utils.log({ id: this.id, message: 'Initializing RPC module from static URLs' });
            this.initCustomNodes(nodes);
        }
        else {
            util_1.Utils.log({ id: this.id, message: 'Initializing RPC module from remote hosts' });
            await this.initRemoteHostsUrls();
        }
        // TODO: consider removing this because we already have a timeout in checkStatuses()
        if (!config.rpc?.oneTimeLoadBalancing) {
            this.timeout = setTimeout(() => this.checkStatuses(), util_1.Constant.OPEN_RPC.LB_INTERVAL);
            // Check if we are running in Node.js environment
            if (typeof process !== 'undefined' && process.release && process.release.name === 'node') {
                process.on('exit', () => this.destroy());
            }
        }
        else {
            await this.checkStatuses();
        }
    }
    destroy() {
        clearTimeout(this.timeout);
    }
    initCustomNodes(nodes) {
        this.initRemoteHosts({ nodeType: tatum_1.RpcNodeType.NORMAL, nodes: nodes, noSSRFCheck: true });
        this.initRemoteHosts({ nodeType: tatum_1.RpcNodeType.ARCHIVE, nodes: nodes, noSSRFCheck: true });
        if (nodes?.length) {
            for (const node of nodes) {
                if (node.type === tatum_1.RpcNodeType.NORMAL) {
                    this.rpcUrls[tatum_1.RpcNodeType.NORMAL].push({
                        node: { url: node.url },
                        lastBlock: 0,
                        lastResponseTime: 0,
                        failed: false,
                    });
                }
                if (node.type === tatum_1.RpcNodeType.ARCHIVE) {
                    this.rpcUrls[tatum_1.RpcNodeType.ARCHIVE].push({
                        node: { url: node.url },
                        lastBlock: 0,
                        lastResponseTime: 0,
                        failed: false,
                    });
                }
            }
        }
        else {
            util_1.Utils.log({ id: this.id, message: 'No RPC URLs provided' });
        }
    }
    async checkStatuses() {
        await this.checkStatus(tatum_1.RpcNodeType.NORMAL);
        await this.checkStatus(tatum_1.RpcNodeType.ARCHIVE);
        if (!this.activeUrl[tatum_1.RpcNodeType.NORMAL].url && !this.activeUrl[tatum_1.RpcNodeType.ARCHIVE].url) {
            util_1.Utils.log({ id: this.id, message: 'No active node found, please set node urls manually.' });
            throw new Error('No active node found, please set node urls manually.');
        }
        const { rpc } = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        if (!rpc?.oneTimeLoadBalancing) {
            if (this.timeout) {
                this.destroy();
            }
            this.timeout = setTimeout(() => this.checkStatuses(), util_1.Constant.OPEN_RPC.LB_INTERVAL);
        }
    }
    async checkStatus(nodeType) {
        const { rpc, network } = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        const all = [];
        /**
         * Check status of all nodes.
         * If the node is not responding, it will be marked as failed.
         * If the node is responding, it will be marked as not failed and the last block will be updated.
         */
        for (const server of this.rpcUrls[nodeType]) {
            util_1.Utils.log({ id: this.id, message: `Checking status of ${server.node.url}` });
            all.push(util_1.Utils.fetchWithTimeout(server.node.url, this.id, {
                method: 'POST',
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                body: JSON.stringify(util_1.Utils.getStatusPayload(network)),
            })
                .then(async ({ response: res, responseTime }) => {
                server.lastResponseTime = responseTime;
                const response = await res.json();
                util_1.Utils.log({
                    id: this.id,
                    message: `Response time of ${server.node.url} is ${server.lastResponseTime}ms with response: `,
                    data: response,
                });
                if (res.ok && response.result) {
                    server.failed = false;
                    server.lastBlock = util_1.Utils.parseStatusPayload(network, response);
                }
                else {
                    util_1.Utils.log({
                        id: this.id,
                        message: `Failed to check status of ${server.node.url}. Error: ${JSON.stringify(response, Object.getOwnPropertyNames(response))}`,
                    });
                    server.failed = true;
                }
            })
                .catch((e) => {
                util_1.Utils.log({
                    id: this.id,
                    message: `Failed to check status of ${server.node.url}. Error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}`,
                });
                util_1.Utils.log({
                    id: this.id,
                    message: `Server ${server.node.url} will be marked as failed and will be removed from the pool.`,
                });
                server.failed = true;
            }));
        }
        /**
         * The fastest node will be selected and will be used.
         */
        await Promise.allSettled(all).then(() => {
            const { fastestServer, index } = LoadBalancer_1.getFastestServer(this.rpcUrls[nodeType], rpc?.allowedBlocksBehind);
            util_1.Utils.log({
                id: this.id,
                data: this.rpcUrls[nodeType],
                mode: 'table',
            });
            if (fastestServer && index !== -1) {
                util_1.Utils.log({
                    id: this.id,
                    message: `Server ${fastestServer.node.url} is selected as active server.`,
                    data: { url: fastestServer.node.url, index },
                });
                this.activeUrl[nodeType] = { url: fastestServer.node.url, index };
            }
        });
    }
    static getFastestServer(servers, allowedBlocksBehind) {
        const { fastestServer, index } = servers.reduce((result, item, index) => {
            const isNotFailed = !item.failed;
            const isFasterBlock = item.lastBlock - allowedBlocksBehind > result.fastestServer.lastBlock;
            const isSameBlockFasterResponse = item.lastBlock === result.fastestServer.lastBlock &&
                item.lastResponseTime < result.fastestServer.lastResponseTime;
            if (isNotFailed && (isFasterBlock || isSameBlockFasterResponse)) {
                return { fastestServer: item, index: index };
            }
            else {
                return result;
            }
        }, { fastestServer: { lastBlock: -Infinity, lastResponseTime: Infinity, node: { url: '' } }, index: -1 });
        return { fastestServer, index };
    }
    getActiveArchiveUrlWithFallback() {
        const activeArchiveUrl = this.getActiveUrl(tatum_1.RpcNodeType.ARCHIVE);
        if (activeArchiveUrl?.url) {
            return { url: activeArchiveUrl.url, type: tatum_1.RpcNodeType.ARCHIVE };
        }
        if (this.getActiveUrl(tatum_1.RpcNodeType.NORMAL)?.url) {
            return { url: this.getActiveUrl(tatum_1.RpcNodeType.NORMAL).url, type: tatum_1.RpcNodeType.NORMAL };
        }
        throw new Error('No active node found.');
    }
    getActiveNormalUrlWithFallback() {
        const activeNormalUrl = this.getActiveUrl(tatum_1.RpcNodeType.NORMAL);
        if (activeNormalUrl?.url) {
            return { url: activeNormalUrl.url, type: tatum_1.RpcNodeType.NORMAL };
        }
        if (this.getActiveUrl(tatum_1.RpcNodeType.ARCHIVE)?.url) {
            return { url: this.getActiveUrl(tatum_1.RpcNodeType.ARCHIVE).url, type: tatum_1.RpcNodeType.ARCHIVE };
        }
        throw new Error('No active node found.');
    }
    getActiveUrl(nodeType) {
        return { url: this.activeUrl[nodeType]?.url, type: nodeType };
    }
    getActiveIndex(nodeType) {
        return this.activeUrl[nodeType]?.index;
    }
    checkSSRF(url) {
        try {
            const parsedUrl = new URL(url);
            return parsedUrl.hostname.endsWith('rpc.tatum.io');
        }
        catch (e) {
            util_1.Utils.log({
                id: this.id,
                message: `Failed to parse URL ${url}. Error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}`,
            });
            return false;
        }
    }
    initRemoteHosts({ nodeType, nodes, noSSRFCheck }) {
        const filteredNodes = nodes.filter((node) => {
            // Check if the node type matches.
            const typeMatch = node.type === nodeType;
            // If noSSRFCheck is true, skip the SSRF check.
            if (noSSRFCheck) {
                return typeMatch;
            }
            // If noSSRFCheck is false or undefined, check if the URL ends with 'rpc.tatum.io'.
            const ssrfCheckPassed = this.checkSSRF(node.url);
            // Log if the URL doesn't pass the SSRF check
            if (!ssrfCheckPassed) {
                util_1.Utils.log({
                    id: this.id,
                    message: `Skipping URL ${node.url} as it doesn't pass the SSRF check.`,
                });
            }
            return typeMatch && ssrfCheckPassed;
        });
        if (filteredNodes.length === 0) {
            return;
        }
        if (!this.rpcUrls[nodeType]) {
            this.rpcUrls[nodeType] = [];
        }
        this.rpcUrls[nodeType] = [
            ...this.rpcUrls[nodeType],
            ...filteredNodes.map((s) => ({
                node: { url: s.url },
                lastBlock: 0,
                lastResponseTime: 0,
                failed: false,
            })),
        ];
        const randomIndex = Math.floor(Math.random() * this.rpcUrls[nodeType].length);
        util_1.Utils.log({
            id: this.id,
            message: `Using random URL ${this.rpcUrls[nodeType][randomIndex].node.url} for ${this.network} blockchain during the initialization for node ${NODE_TYPE_LABEL[nodeType]}.`,
        });
        this.activeUrl[nodeType] = { url: this.rpcUrls[nodeType][randomIndex].node.url, index: randomIndex };
    }
    async initRemoteHostsUrls() {
        const network = this.network;
        const rpcList = util_1.Utils.getRpcListUrl(network);
        util_1.Utils.log({ id: this.id, message: `Fetching response from ${rpcList}` });
        try {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const [normal, archive] = await Promise.all(rpcList.map((url) => fetch(url)));
            if (normal.ok) {
                const nodes = await normal.json();
                this.initRemoteHosts({ nodeType: tatum_1.RpcNodeType.NORMAL, nodes: nodes });
                this.initRemoteHosts({ nodeType: tatum_1.RpcNodeType.ARCHIVE, nodes: nodes });
            }
            else {
                util_1.Utils.log({
                    id: this.id,
                    message: `Failed to fetch RPC configuration for ${network} blockchain for normal nodes`,
                });
            }
            if (archive.ok) {
                const nodes = await archive.json();
                this.initRemoteHosts({ nodeType: tatum_1.RpcNodeType.NORMAL, nodes: nodes });
                this.initRemoteHosts({ nodeType: tatum_1.RpcNodeType.ARCHIVE, nodes: nodes });
            }
            else {
                util_1.Utils.log({
                    id: this.id,
                    message: `Failed to fetch RPC configuration for ${network} blockchain for archive nodes`,
                });
            }
        }
        catch (e) {
            console.error(new Date().toISOString(), `Failed to initialize RPC module. Error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}`);
        }
    }
    async handleFailedRpcCall(rpcCall, e, nodeType) {
        const { rpc: rpcConfig } = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        const { url } = this.getActiveUrl(nodeType);
        const activeIndex = this.getActiveIndex(nodeType);
        util_1.Utils.log({
            id: this.id,
            message: `Failed to call RPC ${Array.isArray(rpcCall) ? 'methods' : rpcCall.method} on ${url}. Error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}`,
        });
        util_1.Utils.log({
            id: this.id,
            message: `Switching to another server, marking ${url} as unstable.`,
        });
        if (activeIndex == null) {
            console.error(`No active server found for node type ${NODE_TYPE_LABEL[nodeType]}.`);
            throw e;
        }
        /**
         * If the node is not responding, it will be marked as failed.
         * New node will be selected and will be used for the given blockchain.
         */
        const servers = this.rpcUrls[nodeType];
        servers[activeIndex].failed = true;
        const { index, fastestServer } = LoadBalancer_1.getFastestServer(servers, rpcConfig?.allowedBlocksBehind);
        if (index === -1) {
            console.error(`All RPC nodes are unavailable.`);
            throw e;
        }
        util_1.Utils.log({
            id: this.id,
            message: `Server ${fastestServer.node.url} is selected as active server, because ${url} failed.`,
        });
        this.activeUrl[nodeType] = { url: fastestServer.node.url, index };
    }
    async rawRpcCall(rpcCall, archive) {
        const { url, type } = archive
            ? this.getActiveArchiveUrlWithFallback()
            : this.getActiveNormalUrlWithFallback();
        try {
            util_1.Utils.log({
                id: this.id,
                message: `Sending RPC ${rpcCall.method} to ${url} for ${this.network} blockchain node type ${type}.`,
            });
            return await this.connector.rpcCall(url, rpcCall);
        }
        catch (e) {
            await this.handleFailedRpcCall(rpcCall, e, type);
            return await this.rawRpcCall(rpcCall);
        }
    }
    async rawBatchRpcCall(rpcCall) {
        const { url, type } = this.getActiveArchiveUrlWithFallback();
        try {
            return await this.connector.rpcCall(url, rpcCall);
        }
        catch (e) {
            await this.handleFailedRpcCall(rpcCall, e, type);
            return await this.rawBatchRpcCall(rpcCall);
        }
    }
    async post({ path, body }) {
        try {
            const { url } = this.getActiveNormalUrlWithFallback();
            return await this.connector.post({ basePath: url, path, body });
        }
        catch (e) {
            util_1.Utils.log({
                id: this.id,
                message: `Failed to call API ${path}. Error: ${JSON.stringify(e, Object.getOwnPropertyNames(e))}`,
            });
            throw e;
        }
    }
    getRpcNodeUrl() {
        return this.getActiveNormalUrlWithFallback().url;
    }
};
LoadBalancer = LoadBalancer_1 = __decorate([
    (0, typedi_1.Service)({
        factory: (data) => {
            return new LoadBalancer_1(data.id);
        },
        transient: true,
    }),
    __metadata("design:paramtypes", [String])
], LoadBalancer);
exports.LoadBalancer = LoadBalancer;
//# sourceMappingURL=LoadBalancer.js.map